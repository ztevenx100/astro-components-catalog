---
/**
 * Progressive Section Loader
 * Carga secciones de componentes de forma progresiva para mejorar rendimiento
 */

export interface Props {
  sectionId: string;
  title: string;
  description?: string;
  priority?: 'high' | 'medium' | 'low';
  loadDelay?: number;
}

const { 
  sectionId, 
  title, 
  description = '', 
  priority = 'medium',
  loadDelay = 0 
} = Astro.props;

const sectionClass = `section section-${priority}`;
---

<section 
  id={sectionId} 
  class={sectionClass}
  data-load-priority={priority}
  data-load-delay={loadDelay}
>
  <div class="section-header">
    <h2>{title}</h2>
    {description && <p class="section-description">{description}</p>}
  </div>
  
  <div class="section-content" data-section-content>
    <div class="section-loader">
      <div class="loader-animation">
        <div class="loader-dot"></div>
        <div class="loader-dot"></div>
        <div class="loader-dot"></div>
      </div>
      <p class="loader-text">Cargando {title.toLowerCase()}...</p>
    </div>
    
    <div class="section-components" style="display: none;">
      <slot />
    </div>
  </div>
</section>

<script>
// Type declarations for better TypeScript support
interface ComponentUtils {
  component?: {
    modalManager?: {
      open: (modalId: string) => void;
    };
    tooltipManager?: {
      show: (element: Element, content: string, position: string) => void;
      hide: (element: Element) => void;
    };
    progressManager?: {
      animate: (element: Element, value: string) => void;
    };
  };
}

declare global {
  interface Window {
    ComponentUtils?: ComponentUtils;
  }
}

class ProgressiveSectionLoader {
  loadQueue = new Map<string, Array<{element: Element, delay: number}>>();
  loadedSections = new Set<string>();
  observer: IntersectionObserver | null = null;

  constructor() {
    this.init();
  }

  init() {
    // Categorize sections by priority
    this.categorizeSections();
    
    // Start loading high priority sections immediately
    this.loadPrioritySections('high');
    
    // Setup intersection observer for medium and low priority sections
    this.setupLazyLoading();
    
    // Load medium priority sections after a short delay
    setTimeout(() => {
      this.loadPrioritySections('medium');
    }, 1000);
  }

  categorizeSections() {
    document.querySelectorAll('[data-load-priority]').forEach(section => {
      const htmlSection = section as HTMLElement;
      const priority = htmlSection.dataset.loadPriority || 'medium';
      const delay = parseInt(htmlSection.dataset.loadDelay || '0') || 0;
      
      if (!this.loadQueue.has(priority)) {
        this.loadQueue.set(priority, []);
      }
      
      this.loadQueue.get(priority)?.push({
        element: section,
        delay: delay
      });
    });
  }

  setupLazyLoading() {
    this.observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const section = entry.target;
          const sectionId = section.id;
          
          if (!this.loadedSections.has(sectionId)) {
            this.loadSection(section);
            this.observer?.unobserve(section);
          }
        }
      });
    }, {
      threshold: 0.1,
      rootMargin: '100px'
    });

    // Observe medium and low priority sections
    ['medium', 'low'].forEach(priority => {
      const sections = this.loadQueue.get(priority) || [];
      sections.forEach(({ element }) => {
        this.observer?.observe(element);
      });
    });
  }

  loadPrioritySections(priority: string) {
    const sections = this.loadQueue.get(priority) || [];
    
    sections.forEach(({ element, delay }) => {
      setTimeout(() => {
        this.loadSection(element);
      }, delay);
    });
  }

  async loadSection(section: Element) {
    const sectionId = section.id;
    
    if (this.loadedSections.has(sectionId)) {
      return;
    }

    try {
      // Mark as loading
      section.classList.add('loading');
      
      // Simulate component loading time
      await this.simulateLoading();
      
      // Show components and hide loader
      this.showSectionContent(section);
      
      // Mark as loaded
      this.loadedSections.add(sectionId);
      section.classList.remove('loading');
      section.classList.add('loaded');
      
      // Dispatch loaded event
      section.dispatchEvent(new CustomEvent('section-loaded', {
        detail: { sectionId }
      }));
      
      // Initialize any interactive components in this section
      this.initializeSectionComponents(section);
      
    } catch (error) {
      console.error(`Failed to load section: ${sectionId}`, error);
      section.classList.add('error');
    }
  }

  simulateLoading(): Promise<void> {
    // Simulate realistic loading time based on content complexity
    const loadTime = Math.random() * 500 + 200; // 200-700ms
    return new Promise(resolve => setTimeout(resolve, loadTime));
  }

  showSectionContent(section: Element) {
    const loader = section.querySelector('.section-loader') as HTMLElement;
    const content = section.querySelector('.section-components') as HTMLElement;
    
    if (loader && content) {
      // Fade out loader
      loader.style.opacity = '0';
      loader.style.transform = 'translateY(-10px)';
      
      setTimeout(() => {
        loader.style.display = 'none';
        content.style.display = 'block';
        
        // Fade in content
        requestAnimationFrame(() => {
          content.style.opacity = '0';
          content.style.transform = 'translateY(10px)';
          content.style.transition = 'all 0.4s ease-out';
          
          requestAnimationFrame(() => {
            content.style.opacity = '1';
            content.style.transform = 'translateY(0)';
          });
        });
      }, 300);
    }
  }

  initializeSectionComponents(section: Element) {
    // Initialize any interactive components that need JavaScript
    const interactiveElements = section.querySelectorAll('[data-interactive]');
    
    interactiveElements.forEach(element => {
      // Initialize based on component type
      const htmlElement = element as HTMLElement;
      const componentType = htmlElement.dataset.interactive;
      
      switch (componentType) {
        case 'modal':
          this.initializeModal(element);
          break;
        case 'tooltip':
          this.initializeTooltip(element);
          break;
        case 'progress':
          this.initializeProgress(element);
          break;
        // Add more component types as needed
      }
    });
  }

  initializeModal(element: Element) {
    // Modal initialization logic
    const triggers = element.querySelectorAll('[data-modal-trigger]');
    triggers.forEach(trigger => {
      trigger.addEventListener('click', (e) => {
        e.preventDefault();
        const htmlTrigger = trigger as HTMLElement;
        const modalId = htmlTrigger.dataset.modalTrigger;
        if (modalId && window.ComponentUtils?.component?.modalManager) {
          window.ComponentUtils.component.modalManager.open(modalId);
        }
      });
    });
  }

  initializeTooltip(element: Element) {
    // Tooltip initialization logic
    const triggers = element.querySelectorAll('[data-tooltip]');
    triggers.forEach(trigger => {
      trigger.addEventListener('mouseenter', () => {
        if (window.ComponentUtils?.component?.tooltipManager) {
          const htmlTrigger = trigger as HTMLElement;
          const content = htmlTrigger.dataset.tooltip || '';
          const position = htmlTrigger.dataset.position || 'top';
          window.ComponentUtils.component.tooltipManager.show(trigger, content, position);
        }
      });
      
      trigger.addEventListener('mouseleave', () => {
        if (window.ComponentUtils?.component?.tooltipManager) {
          window.ComponentUtils.component.tooltipManager.hide(trigger);
        }
      });
    });
  }

  initializeProgress(element: Element) {
    // Progress bar initialization logic
    const progressBars = element.querySelectorAll('.progress-bar[data-progress]');
    progressBars.forEach(bar => {
      if (window.ComponentUtils?.component?.progressManager) {
        const htmlBar = bar as HTMLElement;
        const targetValue = htmlBar.dataset.progress || '0';
        window.ComponentUtils.component.progressManager.animate(bar, targetValue);
      }
    });
  }
}

// Initialize progressive loader
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    new ProgressiveSectionLoader();
  });
} else {
  new ProgressiveSectionLoader();
}
</script>

<style>
.section {
  margin-bottom: 4rem;
  transition: all 0.3s ease;
}

.section.loading {
  opacity: 0.8;
}

.section.loaded {
  opacity: 1;
}

.section.error {
  border-left: 4px solid #ef4444;
  padding-left: 1rem;
  background: #fef2f2;
}

.section-header h2 {
  font-size: 2rem;
  font-weight: 600;
  margin-bottom: 1rem;
  color: var(--text-color);
  text-align: center;
}

.section-description {
  text-align: center;
  color: var(--text-secondary);
  margin-bottom: 2rem;
  font-size: 1.1rem;
}

.section-content {
  position: relative;
  min-height: 200px;
}

.section-loader {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 200px;
  transition: all 0.3s ease;
}

.loader-animation {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 1rem;
}

.loader-dot {
  width: 12px;
  height: 12px;
  background: var(--primary-color, #667eea);
  border-radius: 50%;
  animation: bounce 1.4s ease-in-out infinite both;
}

.loader-dot:nth-child(1) { animation-delay: -0.32s; }
.loader-dot:nth-child(2) { animation-delay: -0.16s; }
.loader-dot:nth-child(3) { animation-delay: 0s; }

.loader-text {
  color: var(--text-secondary);
  font-size: 0.9rem;
  text-align: center;
}

.section-components {
  opacity: 0;
  transform: translateY(10px);
}

@keyframes bounce {
  0%, 80%, 100% { 
    transform: scale(0);
  } 
  40% { 
    transform: scale(1);
  }
}

/* Priority-based styling */
.section-high {
  border-top: 3px solid var(--primary-color, #667eea);
}

.section-medium {
  border-top: 3px solid var(--secondary-color, #f093fb);
}

.section-low {
  border-top: 3px solid var(--accent-color, #4facfe);
}

/* Dark mode support */
html.dark .section.error {
  background: #1f1f1f;
  border-left-color: #ef4444;
}

html.dark .loader-text {
  color: var(--text-secondary, #9ca3af);
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .section {
    margin-bottom: 3rem;
  }
  
  .section-header h2 {
    font-size: 1.5rem;
  }
  
  .section-description {
    font-size: 1rem;
  }
  
  .section-content {
    min-height: 150px;
  }
  
  .section-loader {
    min-height: 150px;
  }
}

/* Performance optimizations */
.section-components > * {
  will-change: auto;
}

.section.loaded .section-components > * {
  will-change: transform, opacity;
}
</style>
